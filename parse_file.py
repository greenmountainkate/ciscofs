# coding=utf-8
"""
Uses BeautifulSoup library to parse input html file into a searchable Python tree object.

Includes functions parse_html_file() to attempt initial parse of file and parse_error to check for any unexpected
structural failures in the form of the tree object generated by the initial parse.

"""
from bs4 import BeautifulSoup as bs
from bs4.diagnose import diagnose
from folderIO import move_to_folder
import time


def parse_html_file(file_to_parse, error_db):
    """
    Parses an html file into a searchable, manipulatable Python tree using the BeautifulSoup library.  Attempts to parse
    file using a cascade of potential html parsers {lxml -> html.parser -> html5lib} ordered from fastest to slowest.
    Errors encountered in parsing are timestamped and logged in the error_files database.

    :param file_to_parse: string holding the path to file to parse
    :param error_db: database to hold error messages as log
    :return: Parsed File Object from BeautifulSoup if parse was successful and None if parse was unsuccessful
    """
    timestamp = time.strftime('%x %X %Z')
    try:
        with open(file_to_parse) as ftp:
            print(file_to_parse)
            # parse html file to tree object
            try:
                soup = bs(ftp, 'lxml')  # lxml is the fastest, but least lenient parser
            except Exception as e:
                error_log = {
                    'Time': timestamp,
                    'File': file_to_parse,
                    'ErrorMessage': [
                        "Error parsing {0} with lxml: {1}".format(file_to_parse, e)
                    ]
                }
                try:
                    soup = bs(ftp, 'html.parser')  # built-in parser, decent speed and leniency
                except Exception as e2:
                    error_log['ErrorMessage'].append(
                        "Error parsing {0} with html.parser: {1}".format(file_to_parse, e2))
                    try:
                        soup = bs(ftp, 'html5lib')  # slowest, most lenient parser
                    except Exception as e3:
                        error_log['ErrorMessage'].append(
                            "Error parsing {0} with html5lib: {1}".format(file_to_parse, e3))
                        error_log['ErrorMessage'].append("BeautifulSoup4 diagnosis: {0}".format(diagnose(ftp.read())))

                        error_db.insert_one(error_log)
                        return None

            return soup
    except Exception as e4:
        error_log = {
            'Time': timestamp,
            'File': file_to_parse,
            'ErrorMessage': [
                "File error: {1}".format(file_to_parse, e4)
            ]
        }
        # write to error collection
        error_db.insert_one(error_log)
        return None

def parse_error(error_db, watch_folder, error_folder, f, pf_obj):
    """
    Checks whether parse was successful by checking status of Parsed File Object.
    A None status indicates that the parse was unsuccessful, and a file which is
    either missing an html body or the html body has no text is useless for text processing,
    so that is also considered to be identified as an error file.

    :param error_db: Mongo database collection where errors messages are logged
    :param watch_folder: String containing path to monitored folder
    :param error_folder: String containing path to folder where unparseable files are stored
    :param f: String containing path to current html file
    :param pf_obj: Parsed File Object generated by BeautifulSoup on current html file
    :return: True if there was a parsing error, False otherwise
    """
    if pf_obj is None:
        # move file to error folder
        move_to_folder(source=watch_folder, dest=error_folder, file=f)
        # move to next file
        return True

    # check for missing or empty html body
    if (pf_obj.body is None) or (pf_obj.body.text.strip() == ""):
        # should this be treated as error?  useless for text analysis
        # log error message
        timestamp = time.strftime('%x %X %Z')
        error_log = {
            'Time': timestamp,
            'File': f,
            'ErrorMessage': 'Error: {0} had missing or empty HTML Body. {1}'.format(f, timestamp),
        }
        error_db.insert_one(error_log)
        move_to_folder(source=watch_folder, dest=error_folder, file=f)
        # move to next file
        return True

    return False